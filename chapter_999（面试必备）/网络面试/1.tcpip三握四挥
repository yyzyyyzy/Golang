TCP标志位
CWR（Congestion Window Reduce）：拥塞窗口减少标志，用来表明它接收到了设置 ECE 标志的 TCP 包。并且，发送方收到消息之后，通过减小发送窗口的大小来降低发送速率。
ECE（ECN Echo）：用来在 TCP 三次握手时表明一个 TCP 端是具备 ECN 功能的。在数据传输过程中，它也用来表明接收到的 TCP 包的 IP 头部的 ECN 被设置为 11，即网络线路拥堵。
URG（Urgent）：表示本报文段中发送的数据是否包含紧急数据。URG=1 时表示有紧急数据。当 URG=1 时，后面的紧急指针字段才有效。
ACK：表示前面的确认号字段是否有效。ACK=1 时表示有效。只有当 ACK=1 时，前面的确认号字段才有效。TCP 规定，连接建立后，ACK 必须为 1。
PSH（Push）：告诉对方收到该报文段后是否立即把数据推送给上层。如果值为 1，表示应当立即把数据提交给上层，而不是缓存起来。
RST：表示是否重置连接。如果 RST=1，说明 TCP 连接出现了严重错误（如主机崩溃），必须释放连接，然后再重新建立连接。
SYN：在建立连接时使用，用来同步序号。当 SYN=1，ACK=0 时，表示这是一个请求建立连接的报文段；当 SYN=1，ACK=1 时，表示对方同意建立连接。SYN=1 时，说明这是一个请求建立连接或同意建立连接的报文。只有在前两次握手中 SYN 才为 1。
FIN：标记数据是否发送完毕。如果 FIN=1，表示数据已经发送完成，可以释放连接。

SYN：同步位（1建立连接，0断开连接）
ACK：确认位（1确认有效，0确认无效）
ack：确认号（等于对方发的序号再+1）
seq：序列号（随机的值）

第一次握手：Client将标志位SYN（同步位）置为1，随机产生一个值seq=J，并将该数据包发送给Server，
          Client进入SYN_SENT状态，等待Server确认。

第二次握手：Server收到数据包后由标志位SYN=1知道Client请求建立连接，Server将标志位SYN和ACK（确认位）都置为1，
          ack（确认号）=J+1，随机产生一个值seq=K，并将该数据包发送给Client以确认连接请求，Server进入SYN_RCVD状态。

第三次握手：Client收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，
          并将该数据包发送给Server，Server检查ack是否为K+1，ACK是否为1，
          如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，
          随后Client与Server之间可以开始传输数据了。

FIN=1断开连接
第一次挥手：Client发送一个FIN=1，seq=x，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态。

第二次挥手：Server收到FIN后，发送一个ACK=1给Client，ack=x+1,seq=y,处于半关闭状态，
          确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），服务端依然能向客户端发数据


第三次挥手：Server发送一个FIN=1，ACK=1，seq=Z，ack=x+1
          用来关闭Server到Client的数据传送，Server进入LAST_ACK状态。

第四次挥手：Client收到FIN后，Client进入TIME_WAIT（2MSL）状态，接着发送一个ACK=1给Server，
          确认序号为收到序号Z+1，ack=x+1，Server进入CLOSED状态，完成四次挥手。

为什么第四次挥手需要等待2MSL：
MSL是报文在网络中最长生存时间
为何一定要等2MSL？如果不等，释放的端口可能会重连刚断开的服务器端口，
这样依然存活在网络里的老的TCP报文可能与新TCP连接报文冲突，造成数据冲突，
为避免此种情况，需要耐心等待网络老的TCP连接的活跃报文全部死翘翘，2MSL时间可以满足这个需求（尽管非常保守）！

为什么是三次握手不是四次：
三次是保证双方互相明确对方能收能发的最低值。
理论上讲不论握手多少次都不能确认一条信道是“可靠”的，但通过3次握手可以至少确认它是“可用”的，
再往上加握手次数不过是提高“它是可用的”这个结论的可信程度。

为什么是三次握手不是两次：
如果一个连接请求在网络中跑的慢，超时了，这时客户端会从发请求，
但是这个跑的慢的请求最后还是跑到了，然后服务端就接收了两个连接请求，然后全部回应就会创建两个连接，浪费资源！
如果加了第三次客户端确认，客户端在接受到一个服务端连接确认请求后，后面再接收到的连接确认请求就可以抛弃不管了。

为什么挥手需要四次：
由于TCP连接是全双工的，因此，每个方向都必须要单独进行关闭，
这一原则是当一方完成数据发送任务后，发送一个FIN来终止这一方向的连接，
收到一个FIN只是意味着这一方向上没有数据流动了，即不会再收到数据了，但是在这个TCP连接上仍然能够发送数据，
直到这一方向也发送了FIN。首先进行关闭的一方将执行主动关闭，而另一方则执行被动关闭

大量TIME_WAIT的后果和解决方案：
后果：在高并发短连接的TCP服务器上，当服务器处理完请求后立刻主动正常关闭连接。这个场景下会出现大量socket处于TIME_WAIT状态。
     如果客户端的并发量持续很高，此时部分客户端就会显示连接不上。
解决方案：改为长连接
        增大可用端口范围