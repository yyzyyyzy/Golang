①局部变量被捕获的情况：
1.函数是golang的头等对象，可以作为参数，返回值，也可以绑定到变量
2.golang称这样的定义方式为Function Value（函数指针）本质上是一个二级指针，指向一个runtime.funcvalue结构体
  这个结构体只会指向一个地址：函数的指令入口地址（main函数为入口地址）
  有捕获列表的funcval结构体通常分配在堆上，没有捕获列表的funcval，编译器会做出优化，在只读数据段分配一个共用的funcval结构体
    type  funcval struct {
        fn uintptr // fn为指针 指向函数指令的入口地址
    }

3.当函数A 被同时赋值给f1、f2两个变量，此时编译器会做出优化，f1、f2共用一个runtime.funcvalue结构体
4.若函数A指令的入口地址为addr1，编译阶段会在只读数据段分配一个funcvalue结构体指针内容为{fn=addr1} 地址为addr2，同时指向函数A指令入口addr1
5.fn结构体的地址（addr2）会在函数执行阶段赋给f1=addr2, f2=addr2（f1，f2为局部变量分配在栈中）
6.通过f1、f2执行调用的函数可以找到addr2结构体的地址，拿到函数f1的入口地址addr1,开始跳转执行A函数的i++，输出i的值2

为什么需要f1、f2在栈中生成二级指针调用函数的入口地址？？？？
1.主要是处理闭包的情况

	func A(i int){
		i++
		fmt.Println(i)
	}
	func B()
	{
		f1 := A
		f1(1)
	}

	func C()
	{
		f2 := A
		f2(1)
	}

1.函数create返回值是func()函数，函数内部使用了外部定义的变量c，即使create执行结束，f1、f2仍然能够调用闭包函数，通常称c为捕获变量
2.闭包函数create的指令在代码段内生成，由于闭包函数需要保存捕获变量c，所以需要在函数调用阶段创建对应的闭包对象
3.函数执行阶段，调用函数main函数先在栈帧中创建两个局部变量f1=nil、f2=nil,被调用函数创建一个局部变量c=2
4.执行f1=create(); 会在堆上动态创建一个funcvalue结构体（fn=addr1）指向闭包函数入口(堆的代码段地址)，同时分配一个捕获列表c=2
5.此结构体fn=addr1的地址（addr2）作为返回值写入main函数的返回值栈帧,所以f1=addr2
6.执行f2=create(); 就会再此在堆上动态创建一个funcvalue结构体（fn=addr1）指向闭包函数入口(堆的代码段地址)，同时分配一个捕获变量c=2
7.此结构体fn=addr1的地址（addr3）作为返回值写入main函数的返回值栈帧,所以f2=addr3
8.通过f1,f2调用闭包函数，就会找到对应的结构体，跳转到同一个闭包函数入口(堆的代码段地址)，但是f1和f2使用的是不同的捕获列表，所以闭包是有状态的

func create() func()int {
    c := 2
    return func() int {
        return c
    }
}

func main() {
    f1 := create()
    f2 := create()
    fmt.Println(f1())
    fmt.Println(f2())
}

那么。闭包函数是如何找到对应的捕获列表呢？
1.当使用funcvalue结构体调用函数时，会把结构体存入特定寄存器，可以通过寄存器取出结构体的地址再加上对应的偏移量找到捕获列表中的每一个变量

捕获列表是单纯的拷贝吗？
1.不是，例如以下代码中被捕获的是局部变量，除了赋值还进行了修改

1.闭包函数create()的指令入口地址为addrf
2.main函数栈帧中局部变量为数组（fs=[nil,nil]），fs是一个元素个数为2（fs[2]）的funcvalue型数组，局部变量，参数，返回值等都需要占用两个栈帧
3.create函数栈帧由于被闭包捕获，堆会动态分配局部变量（i=0），在栈上只存储一个i的地址&i
4.第一次for循环，在堆上创建一个funcvalue结构体（fn=addrf）和捕获列表&i，这样闭包函数和外层函数就可以操作同一个变量
5.main函数的返回值空间存储结构体（fn=addrf）的地址addr0，返回值=[addr0,nil]（栈后进先出）第一次循环结束，i自增1（i=1）
6.第二次for循环，在堆上创建一个funcvalue结构体（fn=addrf）和捕获列表&i，这样闭包函数和外层函数就可以操作同一个变量
7.main函数的返回值空间存储结构体（fn=addrf）的地址addr1，返回值=[addr0,addr1]（栈后进先出）第二次循环结束，i自增1（i=2），此时满足退出循环条件
8.把返回值拷贝到局部变量局部变量fs=[addr0,addr1]
9.通过fs[i]()调用函数时，将addr0存入寄存器，闭包函数通过寄存器存储的地址找到结构体，再通过偏移量找到捕获变量&i，最终得到i的值为2

func create() (fs [2]func()) {
	for i := 0; i < 2; i++ {
		fs[i] = func() {
			fmt.Println(i)
		}
	}
	return
}

func main() {
	fs := create()
	for i := 0; i < len(fs); i++ {
		fs[i]()
	}
}

------------------------------------------------------------------------------------------------------------------------
1.闭包就是有捕获列表的Fuction Value
2.函数是golang的头等对象，可以作为参数，返回值，也可以绑定到变量
3.golang称这样的定义方式为Function Value（函数指针）本质上是一个二级指针，指向一个runtime.funcvalue结构体
  这个结构体只会指向一个地址：函数的指令入口地址（main函数为入口地址）
  有捕获列表的funcval结构体通常分配在堆上，没有捕获列表的funcval，编译器会做出优化，在只读数据段分配一个共用的funcval结构体
    type  funcval struct {
        fn uintptr // fn为指针 指向函数指令的入口地址
    }
闭包从设计角度来说需要保证外层函数和闭包函数的一致性
①局部变量被捕获的情况：
1.局部变量未被修改：直接拷贝值到捕获列表中
2.局部变量被修改：局部变量改为堆分配，栈上存地址，堆分配funcvalue结构体{fn=addr1（函数指令入口地址），&a（捕获列表存储变量的地址）}

②参数被捕获的情况：
1.参数通过调用函数传入栈帧，同时编译器将栈上参数拷贝给堆
2.外层函数和闭包函数都使用堆上分配的这一个

③返回值被捕获的情况：
1.返回值通过调用函数传入栈帧，闭包的外层函数在堆上分配一个
2.外层函数和闭包函数都使用堆上分配的，在外层函数返回前需要将堆上的返回值拷贝到栈上的返回值空间

④所有的被捕获的处理方式都是为了保持外层函数和闭包函数的一致性

