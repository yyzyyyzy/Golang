线程也需要记录标识符、栈执行位置、执行入口、执行现场等
线程可以选择一个执行体（协程）来执行，此时CPU中的执行指针便会指向这个执行体的执行入口，栈基和栈指针寄存器也会指向线程分配的执行栈
切换执行体时，需要先保存当前执行体的执行现场然后切换到另一个执行体，
通过相同的方式，也可以恢复到之前的执行体，可以从上次中断的地方继续执行。

这些由线程创建的执行体就是协程！
因为用户程序不可以操作内核空间，所以只能给协程分配用户栈，而操作系统对协程一无所知，所以协程又称为“用户态线程”

协程都需要指定执行入口，底层都会分配协程执行栈和控制信息，才能负责用户态的调度；
让出协程的执行权时，也要保存执行现场，才能从中断处恢复执行；

所以协程的中心思想是控制流的主动让出和恢复，每个协程都有自己的执行栈，可以保存自己的执行现场，可以由用户程序按需创建协程；
协程主动让出执行权时，保存此时的执行现场，然后切换到其他协程；
协程恢复执行权时，会根据之前保存的执行现场恢复到中断前的状态，继续执行。
这样就实现了轻量灵活的，由用户态调度的多任务模型。

解决了高并发场景下，多进程模型内存资源吃紧，内核态和用户态两头忙，却依然疲于应对的情况。


------------------------------------------------------------------------------------------------------------------------
协程：轻量级的线程，不存在上下文切换，能在多个任务之间调度

线程和进程的操作是由程序触发系统接口，最后的执行者是系统，它本质上是操作系统提供的功能。而协程的操作则是程序员指定的

协程存在的意义：对于多线程应用，CPU通过切片的方式来切换线程间的执行，线程切换时需要耗时。
             协程，则只使用一个线程，分解一个线程成为多个“微线程”，在一个线程中规定某个代码块的执行顺序。

协程的适用场景：当程序中存在大量不需要CPU的操作时（IO）。


协程池：（对于超高并发低延时的情况可以使用协程池，正常情况可以不用）
Goroutine Pool 的实现思路大致如下：
启动服务之时先初始化一个 Goroutine Pool 池，这个Pool维护了一个类似栈的LIFO队列 ，里面存放负责处理任务的Worker，
然后在client端提交task到Pool中之后，在Pool内部，接收task之后的核心操作是：
    1.检查当前Worker队列中是否有空闲的Worker，如果有，取出执行当前的task；
    2.没有空闲Worker，判断当前在运行的Worker是否已超过该Pool的容量，
        是：阻塞等待直至有Worker被放回Pool；否：新开一个Worker（goroutine）处理；
    3.每个Worker执行完任务之后，放回Pool的队列中等待。