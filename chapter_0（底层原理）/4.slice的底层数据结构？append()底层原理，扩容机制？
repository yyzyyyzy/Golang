①slice的底层数据结构是什么？给slice赋值，到底赋了什么内容？

slice实际上是一个结构体类型，包含3个字段，分别是：
1.array: 是指针，指向一个数组，切片的数据实际都存储在这个数组里。
2.len: 切片的长度。
3.cap: 切片的容量。表示切片当前最多可以存储多少个元素，如果超过了现有容量会自动扩容。
  因此给slice赋值，实际上都是给slice里的这3个字段赋值。


②通过 : 操作得到的新slice和原slice是什么关系？新slice的长度和容量是多少？
1. : 可以对数组或者slice做数据截取，:得到的结果是一个新slice。
2.   新slice结构体里的array指针指向原数组或者原slice的底层数组，
3.   新切片的长度是：右边的数值减去左边的数值，新切片的容量是原切片的容量减去:左边的数值。
4. : 的左边如果没有写数字，默认是0，右边没有写数字，默认是被分割的数组或被分割的切片的长度。
5. : 分割操作符右边的数值有上限，上限有2种情况
     如果分割的是数组，那上限是是被分割的数组的长度。
     如果分割的是切片，那上限是被分割的切片的容量。
     注意，这个和下标操作不一样，如果使用下标索引访问切片，下标索引的最大值是(切片的长度-1)，而不是切片的容量。

③append机制
1.append函数返回的是一个切片，append在原切片的末尾添加新元素，这个末尾是切片长度的末尾，不是切片容量的末尾。
2.如果原切片的容量足以包含新增加的元素，那append函数返回的切片结构里3个字段的值是：
  array指针字段的值不变，和原切片的array指针的值相同，也就是append是在原切片的底层数组返回的切片还是指向原切片的底层数组
  len长度字段的值做相应增加，增加了N个元素，长度就增加N
  cap容量不变
3.如果原切片的容量不够存储append新增加的元素，Go会先在堆区分配一块容量更大的新内存，然后把原切片里的所有元素拷贝过来，
  最后在新的内存里添加新元素。append函数返回的切片结构里的3个字段的值是：
  array指针字段的值变了，不再指向原切片的底层数组了，会指向一块新的内存空间
  len长度字段的值做相应增加，增加了N个元素，长度就增加N
  cap容量会增加
4.append不会改变原切片的值，原切片的长度和容量都不变，除非把append的返回值赋值给原切片。

④slice扩容机制
1.源码包src\runtime\slice.go
2.newcap是扩容后的容量，先根据原切片的长度、容量和要添加的元素个数确定newcap大小，最后再对newcap做内存对齐得到最后的newcap。
  进行内存对齐之后，新 slice 的容量是要 大于等于老 slice 容量的2倍或者1.25倍。
3.之后，向 Go 内存管理器申请内存，会匹配到足够大且最接近的规格，将老 slice 中的数据复制过去，并且将 append 的元素添加到新的底层数组中。
4.最后，向 growslice 函数调用者返回一个新的 slice，这个 slice 的长度并没有变化，而容量却增大了。

例如：
    s := []int{1, 2}
   	s = append(s, 4, 5, 6)
   	fmt.Printf("len=%d, cap=%d", len(s), cap(s))

1.预估扩容后的容量，扩容前容量为2，如果扩容前的容量的两倍仍然小于所需最小容量，那么预估容量等于所需最小容量
2.否则直接看扩容前的元素个数是否小于1024，小于就直接容量翻倍；若大于1024，则扩容至1.25倍
3.内存对齐：使用预估容量乘以元素类型大小得到所需内存，将预估申请内存匹配到合适的内存规格

