TCP标志位
CWR（Congestion Window Reduce）：拥塞窗口减少标志，用来表明它接收到了设置 ECE 标志的 TCP 包。并且，发送方收到消息之后，通过减小发送窗口的大小来降低发送速率。
ECE（ECN Echo）：用来在 TCP 三次握手时表明一个 TCP 端是具备 ECN 功能的。在数据传输过程中，它也用来表明接收到的 TCP 包的 IP 头部的 ECN 被设置为 11，即网络线路拥堵。
URG（Urgent）：表示本报文段中发送的数据是否包含紧急数据。URG=1 时表示有紧急数据。当 URG=1 时，后面的紧急指针字段才有效。
ACK：表示前面的确认号字段是否有效。ACK=1 时表示有效。只有当 ACK=1 时，前面的确认号字段才有效。TCP 规定，连接建立后，ACK 必须为 1。
PSH（Push）：告诉对方收到该报文段后是否立即把数据推送给上层。如果值为 1，表示应当立即把数据提交给上层，而不是缓存起来。
RST：表示是否重置连接。如果 RST=1，说明 TCP 连接出现了严重错误（如主机崩溃），必须释放连接，然后再重新建立连接。
SYN：在建立连接时使用，用来同步序号。当 SYN=1，ACK=0 时，表示这是一个请求建立连接的报文段；当 SYN=1，ACK=1 时，表示对方同意建立连接。SYN=1 时，说明这是一个请求建立连接或同意建立连接的报文。只有在前两次握手中 SYN 才为 1。
FIN：标记数据是否发送完毕。如果 FIN=1，表示数据已经发送完成，可以释放连接。

SYN：同步位（1建立连接，0断开连接）
ACK：确认位（1确认有效，0确认无效）
ack：确认号（等于对方发的序号再+1）
seq：序列号（随机的值）

第一次握手：Client将标志位SYN（同步位）置为1，随机产生一个值seq=J，并将该数据包发送给Server，
          Client进入SYN_SENT状态，等待Server确认。

第二次握手：Server收到数据包后由标志位SYN=1知道Client请求建立连接，Server将标志位SYN和ACK（确认位）都置为1，
          ack（确认号）=J+1，随机产生一个值seq=K，并将该数据包发送给Client以确认连接请求，Server进入SYN_RCVD状态。

第三次握手：Client收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，
          并将该数据包发送给Server，Server检查ack是否为K+1，ACK是否为1，
          如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，
          随后Client与Server之间可以开始传输数据了。

FIN=1断开连接
第一次挥手：Client发送一个FIN=1，seq=x，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态。

第二次挥手：Server收到FIN后，发送一个ACK=1给Client，ack=x+1,seq=y,处于半关闭状态，
          确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），服务端依然能向客户端发数据


第三次挥手：Server发送一个FIN=1，ACK=1，seq=Z，ack=x+1
          用来关闭Server到Client的数据传送，Server进入LAST_ACK状态。

第四次挥手：Client收到FIN后，Client进入TIME_WAIT（2MSL）状态，接着发送一个ACK=1给Server，
          确认序号为收到序号Z+1，ack=x+1，Server进入CLOSED状态，完成四次挥手。

为什么第四次挥手需要等待2MSL：
MSL是报文在网络中最长生存时间
为何一定要等2MSL？如果不等，释放的端口可能会重连刚断开的服务器端口，
这样依然存活在网络里的老的TCP报文可能与新TCP连接报文冲突，造成数据冲突，
为避免此种情况，需要耐心等待网络老的TCP连接的活跃报文全部死翘翘，2MSL时间可以满足这个需求（尽管非常保守）！

为什么是三次握手不是四次：
三次是保证双方互相明确对方能收能发的最低值。
理论上讲不论握手多少次都不能确认一条信道是“可靠”的，但通过3次握手可以至少确认它是“可用”的，
再往上加握手次数不过是提高“它是可用的”这个结论的可信程度。

为什么是三次握手不是两次：
如果一个连接请求在网络中跑的慢，超时了，这时客户端会从发请求，
但是这个跑的慢的请求最后还是跑到了，然后服务端就接收了两个连接请求，然后全部回应就会创建两个连接，浪费资源！
如果加了第三次客户端确认，客户端在接受到一个服务端连接确认请求后，后面再接收到的连接确认请求就可以抛弃不管了。

为什么挥手需要四次：
由于TCP连接是全双工的，因此，每个方向都必须要单独进行关闭，
这一原则是当一方完成数据发送任务后，发送一个FIN来终止这一方向的连接，
收到一个FIN只是意味着这一方向上没有数据流动了，即不会再收到数据了，但是在这个TCP连接上仍然能够发送数据，
直到这一方向也发送了FIN。首先进行关闭的一方将执行主动关闭，而另一方则执行被动关闭

大量出现 TIME_WAIT 状态通常是由于频繁建立和关闭 TCP 连接。解决方法如下：

使用长连接：避免频繁创建和关闭连接，采用持久连接（如 HTTP 长连接）来复用连接。
使用连接池：通过连接池复用连接，减少连接的创建和销毁。
调整系统参数：在 Linux 上，可以通过调整 tcp_fin_timeout 参数来减少 TIME_WAIT 的持续时间。
启用端口复用：使用 SO_REUSEADDR 或 SO_REUSEPORT 来复用处于 TIME_WAIT 状态的端口，但要小心确保不会影响 TCP 协议的可靠性。
优化应用逻辑：避免短连接的高频创建，减少无效连接的数量。
通过这些方法，可以减少 TIME_WAIT 状态的数量，提升系统的资源利用率。

大量出现 CLOSE_WAIT 状态通常是因为应用程序没有及时读取接收到的数据或者没有正确关闭连接。解决方法如下：

及时读取数据：确保在连接关闭前，应用能够及时读取接收缓冲区的数据，避免堆积未读取的数据。
正确关闭连接：在数据处理完成后，确保调用 close() 正确关闭连接，避免连接长时间处于 CLOSE_WAIT 状态。
检查代码中的连接关闭逻辑：确认每个 close() 调用后是否有相应的读取操作，以及是否有错误导致连接未能被完全关闭。
增加心跳机制：对于长时间保持连接的场景，可以增加心跳检测，及时发现和清理不活跃的连接。
通过这些措施可以有效减少 CLOSE_WAIT 状态的堆积。