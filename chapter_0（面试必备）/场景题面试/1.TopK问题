TopK问题整体思路：
1.维护一个大小为 K 的小顶堆，依次将数据放入堆中，当堆的大小满了的时候，只需要将堆顶元素与下一个数比较：如果大于堆顶元素，则将当前的堆顶元素抛弃，并将该元素插入堆中。
  遍历完全部数据，Top K 的元素也自然都在堆里面了。
2.如果是求前 K 个最小的数，只需要改为大顶堆即可

①十亿个数找出最大的一万个数

1.直接排序--性能较差

2.采用分治的思想：1.把十亿个数分开存放，例如放在一千个文件中，在这些文件中分别找出最大的一万个数，再合并处理，这样就可以充分利用多线程的优势
               2.当然，线程之间的处理速度不同，快的要等慢的，如果每个线程要负责的量是一样的，这样总时间取决于最慢的那个线程
               3.优化：1.快的线程处理完可以帮慢线程处理慢线程的下一份数据；
                      2.每个数据对象使用一个标记变量表示是否已经被拿去处理

②几百个文件，内存只有1G，怎么从中提取想要的key与value，怎么依次提取出最小的key？

1.维护一个大小为 K 的大顶堆，依次将数据放入堆中，当堆的大小满了的时候，只需要将堆顶元素与下一个数比较：如果大于堆顶元素，则将当前的堆顶元素抛弃，并将该元素插入堆中。
  遍历完全部数据，Top K 的元素也自然都在堆里面了。


③TopK整数
1.最直观：小顶堆（大顶堆 -> 最小100个数）；
2.较高效：Quick Select算法：（Quick Select的目标是找出第k大元素）
    若切分后的左子数组的长度 > k，则第k大元素必出现在左子数组中；
    若切分后的左子数组的长度 = k-1，则第k大元素为pivot；
    若上述两个条件均不满足，则第k大元素必出现在右子数组中。