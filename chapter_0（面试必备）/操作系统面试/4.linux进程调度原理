Linux进程调度的目标
　　　　1.高效性：高效意味着在相同的时间下要完成更多的任务。调度程序会被频繁的执行，所以调度程序要尽可能的高效；
　　　　2.加强交互性能:在系统相当的负载下，也要保证系统的响应时间；
　　　　3.保证公平和避免饥渴；
　　　　4.SMP调度：调度程序必须支持多处理系统；
　　　　5.软实时调度：系统必须有效的调用实时进程，但不保证一定满足其要求；

实现部分主要4个点：时间记账，进程选择，调度器入口，睡眠和唤醒

①时间记账
所有的调度器都必须对进程的运行时间做记账。CFS不再有时间片的概念，维护了每个进程运行的时间记账，因为每个进程只在公平分配给它的处理器时间内运行。关键数据结构如下：
vruntime: 虚拟运行时间是在所有可运行基础的总数上计算出一个进程应该运行多久，
          计算时相应的nice值在CFS被作为进程获得处理器运行比的权重：越高的nice（越低优先级）值，获得更低的处理器权重，更低的nice值获得更高的处理器使用权重。
个人理解：CFS的vruntime += 处理器运行时间 * nice对应的权重

②进程选择
进程选择是CFS调度算法的最重要的模块，当CFS调度器选择下一个要进行调度的进程时，就会选择具有最小vruntime的任务。
涉及到获取最小值，以及有序数据结构，在各种场景下都很适用的红黑树就发挥了其作用。
即用红黑树维护以vruntime为排序条件，存储着任务的运行情况。进程的维护都在红黑树上进行相关操作：
1. 选择下一个任务
执行__pick_next_entity函数即获取了红黑树最左的节点（最小值）。
2. 向红黑树中加入进程
这一步骤发生在进程变成可运行态，或者通过fork系统调用第一次创建进程时。
3. 从红黑树中删除进程
这一步操作发生在进程阻塞，即进程变成不可运行状态或者当进程终止时。

③调度器入口
进程调度器的入口函数为schedule()，总体流程即为选择合适的调度策略选出下一个需要被调度的进程任务，然后进行一次上下文切换，将进程置为运行态。

④睡眠和唤醒
休眠（被阻塞）状态的进程处于不可执行的状态。进程休眠的原因有多种多样，但通常来说都是等待某一事件的发生，例如等待I/O, 等待设备输入等等。
内核对于休眠和唤醒的操作如下：
休眠：进程首先把自己标记为休眠状态(TASK_INTERRUPTIBLE)，然后从可执行红黑树中移除该进程，并将进程放入等待队列
唤醒：进程被置为可执行状态(TASK_RUNNING)，进程从等待队列移入可执行红黑树中
休眠或者阻塞状态有两种：可中断休眠(TASK_INTERRUPTIBLE), 不可中断休眠(TASK_UNINTERRUPTIBLE).
通常进程的休眠，为可中断休眠，即进程进入休眠，等待某一事件发生。一旦事件发生，或者满足条件，内核将会把进程状态置为运行，并将进程从等待队列中移除。

⑤抢占和上下文切换
上下文切换，处理器从即为从一个可执行的进程切换到另一个可执行的进程，其中包含了两个关键的函数.

总结
CFS是动态计算程序优先级的一种调度算法，其内部算法核心是选取vruntime最小的进程进行调度运行，
而维护最小的进程，使用了红黑树，而计算vruntime使用了所有进程数以及nice值的加权。
Linux内核的调度程序CFS，尽可能的满足了各个方面的需求，并找到了一种在调度周期和吞吐量之间的平衡。