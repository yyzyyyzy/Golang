内连接（inner join）：取出两张表中匹配到的数据，匹配不到的不保留
语句：select * from 表1 inner join 表2 where 表1.XX=表2.XX；

外连接（outer join）：取出连接表中匹配到的数据，匹配不到的也会保留，其值为NULL
外连接分为左连接和右连接

左连接，左表显示所有数据，右表只匹配符合条件的数据行，右表中没有则以null显示
右连接，右表显示所有数据，左表只匹配符合条件的数据行，左表中没有则以null显示
左连接where只影向右表，右连接where只影响左表。


join的底层原理：MySQL使用Nested-Loop Join，分为三种实现：
    Simple Nested-Loop Join：SNLJ，简单嵌套循环连接（简单粗暴的嵌套循环）
        1.如果table1有1万条数据，table2有1万条数据，那么数据比较的次数=1万 * 1万 =1亿次，这种查询效率会非常慢。
    Index Nested-Loop Join：INLJ，索引嵌套循环连接（减少内层表数据的匹配次数）
        1.索引嵌套循环连接是基于索引进行连接的算法，索引是基于内层表的，通过外层表匹配条件直接与内层表索引进行匹配，避免和内层表的每条记录进行比较，
          从而利用索引的查询减少了对内层表的匹配次数，优势极大的提升了 join的性能：
    Block Nested-Loop Join：BNLJ，缓存块嵌套循环连接（减少内层表数据的循环次数）
        1.缓存块嵌套循环连接通过一次性缓存多条数据，把参与查询的列缓存到Join Buffer 里，然后拿join buffer里的数据批量与内层表的数据进行匹配，
          从而减少了内层循环的次数（遍历一次内层表就可以批量匹配一次Join Buffer里面的外层表数据）。

如何优化Join速度
1.用小结果集驱动大结果集，减少外层循环的数据量，从而减少内层循环次数：
2.如果小结果集和大结果集连接的列都是索引列，mysql在内连接时也会选择用小结果集驱动大结果集，因为索引查询的成本是比较固定的，这时候外层的循环越少，join的速度便越快。
3.为匹配的条件增加索引：争取使用INLJ，减少内层表的循环次数
4.增大join buffer size的大小：当使用BNLJ时，一次缓存的数据越多，那么内层表循环的次数就越少
5.减少不必要的字段查询：
（1）当用到BNLJ时，字段越少，join buffer 所缓存的数据就越多，内层表的循环次数就越少；
（2）当用到INLJ时，如果可以不回表查询，即利用到覆盖索引，则可能可以提示速度。（未经验证，只是一个推论）


笛卡尔积：又称交叉连接，将两（或多）个表的所有行进行组合，连接后的行数为两（或多）个表的乘积数.
实例应用：select * from A,B
出现原因：缺少关联条件或者关联条件不准确
