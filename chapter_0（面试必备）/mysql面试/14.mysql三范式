第一范式：列不可再分
第一范式的目标是确保每列的原子性:如果每列都是不可再分的最小数据单元（也称为最小的原子单元），则满足第一范式（1NF）

第二范式：行可以唯一区分，主键约束
首先满足第一范式，并且表中非主键列不存在对主键的部分依赖。 第二范式要求每个表只描述一件事情。

第三范式：表的非主属性不能依赖与其他表的非主属性 外键约束
且三大范式是一级一级依赖的，第二范式建立在第一范式上，第三范式建立第一第二范式上 。
第三范式定义是，满足第二范式，并且表中的列不存在对非主键列的传递依赖。
除了主键订单编号外，顾客姓名依赖于非主键顾客编号。


我们设计数据库应该用哪个范式？
第二范式
惟一性：要求记录有惟一标识，即实体的惟一性，即不存在部分依赖
表：学号、课程号、姓名、学分; 这个表明显说明了两个事务:学生信息, 课程信息;由于非主键字段必须依赖主键，这里学分依赖课程号，姓名依赖与学号，所以不符合二范式。
可能会存在问题：
数据冗余:，每条记录都含有相同信息；
删除异常：删除所有学生成绩，就把课程信息全删除了；
插入异常：学生未选课，无法记录进数据库；
更新异常：调整课程学分，所有行都调整
正确做法: 学生：Student(学号, 姓名)； 课程：Course(课程号, 学分)； 选课关系：StudentCourse(学号, 课程号, 成绩)。

第三范式
冗余性：要求任何字段不能由其他字段派生出来，它要求字段没有冗余，即不存在传递依赖； 表: 学号, 姓名, 年龄, 学院名称, 学院电话
因为存在依赖传递: (学号) → (学生)→(所在学院) → (学院电话)
可能会存在问题：
数据冗余:有重复值；
更新异常：有重复的冗余信息，修改时需要同时修改多条记录，否则会出现数据不一致的情况 。
正确做法：
学生：(学号, 姓名, 年龄, 所在学院)
学院：(学院, 电话)

范式化
优点：1·可以尽量的减少数据冗余 2·数据表更新快体积小 3·范式化的更新操作比反范式化更快 4·范式化的表通常比反范式化更小
缺点：1·对于查询需要对多个表进行关联，导致性能降低 2·更难进行索引优化

反范式化
优点 1·可以减少表的关联 2·可以更好地进行索引优化
缺点 1·存在数据冗余及数据维护异常 2·对数据的修改需要更多成本

缺点如下：
数据表存在数据冗余及数据维护异常
对数据的修改需要更多的成本