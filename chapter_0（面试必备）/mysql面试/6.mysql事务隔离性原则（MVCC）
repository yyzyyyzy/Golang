mvcc原理：多版本并发控制
         MVCC是通过在每行记录后面保存两个隐藏的列来实现的。这两个列，一个保存了行的创建时间，一个保存行的过期时间（或删除时间）。
         当然存储的并不是实际的时间值，而是系统版本号。每开始一个新的事务，系统版本号都会自动递增。
         事务开始时刻的系统版本号会作为事务的版本号，用来和查询到的每行记录的版本号进行比较。

MVCC实现的问题（数据库的隔离级别）
    MVCC可以实现读已提交和可重复读，通过三个隐藏字段（事务ID、回滚指针、隐藏主键）和Undolog形成版本链、ReadView规定了版本链的访问规则。从而实现读已提交和可重复读

mvcc目的：MVCC在MySQL InnoDB中的实现主要是为了提高数据库并发性能，用更好的方式去处理读-写冲突，
         做到即使有读写冲突时，也能做到不加锁，非阻塞并发读

Bin Log:是mysql服务层产生的日志，常用来进行数据恢复、数据库复制，常见的mysql主从架构，就是采用slave同步master的binlog实现的

Redo Log:记录了数据操作在物理层面的修改，mysql中使用了大量缓存，修改操作时会直接修改内存，而不是立刻修改磁盘，
         事务进行中时会不断的产生redo log，在事务提交时进行一次flush操作，保存到磁盘中。当数据库或主机失效重启时，
         会根据redo log进行数据的恢复，如果redo log中有事务提交，则进行事务提交修改数据。

Undo Log: 除了记录redo log外，当进行数据修改时还会记录undo log，undo log用于数据的撤回操作，它记录了修改的反向操作，
          比如，插入对应删除，修改对应修改为原来的数据，通过undo log可以实现事务回滚，并且可以根据undo log回溯到某个特定的版本的数据，实现MVCC

当前读：读取的都是最新版本，最新数据：
像select lock in share mode(共享锁), select for update ; update, insert ,delete(排他锁)
这些操作都是一种当前读，为什么叫当前读？就是它读取的是记录的最新版本，
读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁。(悲观锁的一种实现)

快照读：读取的是历史版本的记录:
    select....

mvcc可见性算法：
第一部分：
隐藏字段：每一行记录包含用户几个不可见的字段
    DB_TRX_ID：创建或者最后一次修改该记录的事务id
    DB_ROW_ID：隐藏主键（主键不存在时会存在此字段）
    DB_ROLL_PTR：事务失败，回滚指针到上一条历史版本记录，配合undolog日志使用

例如：事务1创建新表
name age gender DB_TRX_ID DB_ROW_ID DB_ROLL_PTR
lzk  18  male   1         1         null

第二部分：
回滚日志（undolog）：保存日志的历史版本状态
当不同事务对同一个表进行修改时，undolog会形成一个线性链表，
链首是最新的历史版本记录，链尾是最初的历史版本记录

例如：事务2修改name="whc"
1.首先先保存历史版本在undolog，防止事务失败回滚
2.修改表记录：
name age gender DB_TRX_ID DB_ROW_ID DB_ROLL_PTR
whc  18  male   2         1         0x123（undolog历史版本记录的地址）

第三部分：
readview：事务在进行快照读时的读视图
    min_id：创建的最小版本事务id
    max_id：创建的最大版本事务id

如果trx_id<min_id，表示这个版本是已提交的事物生成的，这个数据是可见的
如果trx_id>max_id，表示这个版本是由将来启动的事务生成的，是肯定不可见的
如果min_id<=trx_id<=max_id，那就包括两种情况：
若row的trx_id在数组中，表示这个版本是由还没提交的事务生成的，不可见，当前自己的事务是可见的
若row的trx_id不在数组中，表示这个版本是已经提交的事务生成的，是可见的

