如何解决幻读？
我们现在知道产生幻读的原因是，行锁只能锁住行，但是新插入记录这个动作，
要更新的是记录之间的“间隙”。因此，为了解决幻读问题，InnoDB引入了间隙锁（Gap Lock）。
间隙锁的应用场景包括并发读取、并发更新、并发删除和并发插入。

间隙锁，锁住某个范围，但不包括记录本身。比如前面说到的表t，初始化有6条记录，这就产生了7个间隙。
当你执行select * from t where d=5 for update的时候，
就不止是给数据库中6个记录加了行锁，还同时加了7个间隙锁。这样就确保了无法再插入新的记录。

也就是说这时候，在一行行扫描的过程中，不仅给行加上行锁，还给行两边的空隙也加上间隙锁。

经过T1时刻，id=5这一行变成 (5,5,100)，当然这个结果最终是在T6时刻正式提交的。
因为select * from t where d=6 for update，对6个记录加了行锁，同时加了7个间隙锁。
经过T2时刻，Session B被阻塞，因为id=0这一行被锁;
经过T4时刻，Session C被阻塞，因为主键索引上加了间隙锁(0,5)，所以id=1这个值无法被插入;
Session B和Session C都要等待Session A释放锁后才能继续执行，这样就解决了幻读的问题。

行锁保证更新行，间隙锁保证插入行，而行锁+间隙锁=Next-Key Lock
，也就是本文开头说到的，InnoDB是通过Next-Key Lock来解决幻读问题的。

但是间隙锁的引入，可能会导致同样的语句锁住更大的范围，这会影响并发度的。
比如上面的select * from t where d=5 for update，相当于加了表

