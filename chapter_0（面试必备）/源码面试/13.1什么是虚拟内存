①物理内存和虚拟内存的映射
当可执行文件加载到内存中就成为了一个运行的程序（进程）
dos时期的进程：1。采用的是实地址模式：进程直接使用物理地址（进程可以仍以修改物理内存，很容易发生占用其他进程内存的情况，甚至覆盖操作系统使用的内存）
             2.后来使用保护模式，进程不直接使用物理内存地址，使用虚拟内存地址，被称为线性地址

操作系统：1.负责把线性地址映射到物理内存地址，保护模式提供内存分页机制（32位系统每4k作为一页），映射也是使用页作为单位映射的
        2.用链表的形式记录每个进程的控制信息，在windows中称为进程控制块（PCB），在Linux中对应task_struct结构体
        3.每个进程的控制信息中都有一个指针存储的是”页目录“的物理地址，页目录也是一个内存页，存储的是”页表“的指针
          页目录和页表存储的是指向同样存储物理内存页起始地址

32位操作系统，一个内存地址（指针）占4字节，一个页目录可以寻址1024个页表，每个页表可以寻址1024个物理内存页，1024*1024*4kb=4GB
            所以只需要两级页表，就可以寻址4GB的内存空间了

线性地址格式：0000000000 0000000001 xxxxxxxxxxxx
           前十位可以从页目录选择一个页表
           中间十位可以从对应页表中选择一个物理内存页
           最后十二位会用来存储一个相对于内存起始地址的偏移值（可以正好覆盖4k个偏移值，足够定义到每一个地址）

此时便完成了虚拟内存中一个内存页到物理内存地址的映射，
每个进程可以对应自己的页表，这样在不同进程中，相同的线性地址也会映射到不同的物理内存地址，从而实现了进程内存地址隔离
还可以通过把同一组物理页面映射到不同进程的页表中，实现进程间共享内存

②
内存页的起始地址因为内存也大小为4kb，则一定是4k的整数倍，它的低十二位一定是0，
所以页表里每一条记录都有12位空闲空间使用，用来标识物理内存页”可读可写可执行“等信息，其中有一位表标识该物理内存页是否已经映射

因为进程向操作系统申请映射内存时，操作系统会先记录，直到进程访问这段内存时才会执行，所以进程的虚拟内存空间只是进程可以申请使用的一个范围，
只有真正被映射到物理内存才是能够合法使用的虚拟内存，未被映射到物理内存的部分，属于不合法的线性地址，要使用必须先映射

线性地址到物理内存的转换会交给CPU中的内存管理单元MMU负责，当前进程页目录的物理地址会被保存到寄存器中，
这样CPU可以借助页目录和页表把线性地址转换为物理地址了

③
由于频繁查询页表会影响效率，CPU会把进程已经转换过的映射关系缓存到TLB中，需要转换先去TLB查找，没有的话再去找页表，然后写入TLB
如果需要切换到另一个进程执行，那么寄存器存储的页目录也会发生改变，之前的TLB缓存也会失效，需要重新查询页表建立新的缓存数据，这也是进程切换代价高的原因
如果CPU查询页表发现对应物理内存页没有完成映射就会发生Page Fault，
处理这个异常的Page Fault Handler会去进程控制信息查询进程是否申请了这段内存，
如果已经申请了，就实际分配物理页面完成页表映射，然后正常使用，如果没有申请过，就会发生内存访问异常，这样设计为了保障效率，内存映射比较耗时

总结:
1.虚拟内存中连续存储解决了物理内存碎片化资源利用率过低的问题
2.每个进程只能访问自己独立的用户空间而内核空间是共用的，解决了进程间的安全问题
3.缺页异常和选择牺牲页的算法提高了内存读写的效率