时间复杂度指的是算法运行所需时间的增长率，常用大O符号表示。以下是一些常见算法的时间复杂度及其举例：

O(1) 常数时间复杂度，表示算法的执行时间不随输入规模变化而变化，例如访问数组中某个元素。

O(log n) 对数时间复杂度，表示算法的执行时间随输入规模的增加而增加，但是增速不会很快，例如二分查找。

O(n) 线性时间复杂度，表示算法的执行时间与输入规模成线性关系，例如遍历一个数组。

O(n log n) 线性对数时间复杂度，表示算法的执行时间随输入规模的增加而增加，并且增速比线性更快，例如快速排序。

O(n^2) 平方时间复杂度，表示算法的执行时间随输入规模的增加而增加，并且增速比线性更快，例如冒泡排序。

O(2^n) 指数时间复杂度，表示算法的执行时间随着输入规模的增加呈指数级增长，例如求解斐波那契数列。

这些仅仅是常见算法的时间复杂度及其举例，实际上还有很多其他的复杂度表示方式和算法。


示例：

1. 时间复杂度为O(n)
for i, v := range nums {
}

2. 时间复杂度为O(n^2)
for i, v := range nums {
    for j, k := range nums2 {
    }
}

3. 时间复杂度为O(n log n)
sort.Ints(nums)



空间复杂度指的是算法执行所需的内存空间，同样使用大O符号表示。以下是一些常见算法的空间复杂度及其举例：

O(1) 常数空间复杂度，表示算法执行所需的内存空间是固定的，与输入规模无关，例如交换两个变量的值。

O(n) 线性空间复杂度，表示算法执行所需的内存空间随着输入规模的增加而线性增加，例如开辟一个数组，并按顺序存储数据。

O(n^2) 平方空间复杂度，表示算法执行所需的内存空间随着输入规模的增加呈平方级增加，例如开辟一个二维数组，并按照行列顺序存储数据。

O(log n) 对数空间复杂度，表示算法执行所需的内存空间随着输入规模的增加而对数级增加，例如递归求解二分查找。

O(n log n) 线性对数空间复杂度，表示算法执行所需的内存空间随着输入规模的增加而线性对数级增加，例如快速排序。

这些仅仅是常见算法的空间复杂度及其举例，实际上还有很多其他的复杂度表示方式和算法。


示例：

1. 空间复杂度为O(1)
a, b := 1, 2

2. 空间复杂度为O(n)
var nums []int

3. 空间复杂度为O(n^2)
var nums [][]int

4. 空间复杂度为O(log n)
func fib(n int) int {
    if n <= 1 {
        return n
    }
    return fib(n-1) + fib(n-2)
}

5. 空间复杂度为O(n log n)
func mergeSort(nums []int) []int {
    if len(nums) <= 1 {
        return nums
    }
    mid := len(nums) / 2
    left := mergeSort(nums[:mid])
    right := mergeSort(nums[mid:])
    return merge(left, right)
}
